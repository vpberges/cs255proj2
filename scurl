#!/usr/bin/env python
'''
CS 255, Winter 2017
Project 2: scurl - Secure curl

Group:
    Jon Deaton, jdeaton@stanford.edu
    Vincent-Pierre Berges, vpberges@stanford.edu
'''

import os
import sys
import OpenSSL
import socket
import urlparse
import argparse
import datetime
import re

class SecureCurl(object):
    # This class implements the functionality of curl but with TLS

    def __init__(self, method, ciphers=None, crlfile=None, pinnedcertificate=None,
                 cacert=None, allow_stale_certs=False):

        self.default_port = 443 # Default port for HTTPS requests
        self.packet_end = b'\r\n\r\n' # End of buffer
        self.timeout = 1 # socket.rev() timeout in seconds
        self.buffer_size = 1024 # Buffer size for packet recieving in bytes

        # Set instance vairables based on those from construction
        self.ciphers = ciphers
        self.method = method
        self.crlfile = crlfile
        self.cacert = cacert
        self.pinnedcertificate = pinnedcertificate
        self.allow_stale_certs = allow_stale_certs

        # The verification mode used for Context.set_verify(mode, calback)
        # IDK what this is really i just got this from somewhere online
        # self.verify_mode = OpenSSL.SSL.VERIFY_PEER |\
        #                    OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT | \
        #                    OpenSSL.SSL.VERIFY_CLIENT_ONCE

        self.verify_mode = OpenSSL.SSL.VERIFY_NONE
        self.verify_mode = OpenSSL.SSL.VERIFY_PEER

        # This will contain a lookup table of hexidecmial encoded certificate cerial numbers
        self.revocations = None
        self.set_CRL()

    def make_context(self):
        # Initialize the context
        context = OpenSSL.SSL.Context(self.method)

        # For SNI hostname verification
        context.check_hostname = True

        # Set the ciphers if necessary
        if self.ciphers is not None:
            context.set_cipher_list(self.ciphers)

        # Specify the CA Certificate to use for verification
        if self.cacert is not None:
            try:
                f = open(self.cacert, 'r')
                crt_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading CA certificate file: %s\n" % self.cacert)
                exit(1)

            # Use the certificate provided
            try:
                ca_crt = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, crt_buff)
            except:
                sys.stderr.write("Error loading CA certificate from: %s\n" % self.cacert)
                exit(1)

            # CA Certificate was loaded properly so specify that it should be used
            context.use_certificate(ca_crt)

        # Set the verify callback
        context.set_verify(self.verify_mode, self.verify)

        return context

    def set_CRL(self):
        # Set the Certificate Revocation List if one was provided by the --crlfile argument
        if self.crlfile is not None:
            try:
                f = open(self.crlfile, 'r')
                crl_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading CRL file: %s\n" % self.crlfile)
                raise

            # Load the buffer into an OpenSSL CRL object
            crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, crl_buff)
            # Create a lookup table for revocations. These are formatted as capital hex strings
            self.revocations = set(map(lambda x: x.get_serial(), crl.get_revoked()))

    def hostname_match(self, hostname, pattern):
        if "*" in pattern:
            # rxString = r'(?:^|\s)(\w+\.)?' + pattern.replace('.', '\.')[3:] + '(?:$|\s)'
            # regex = re.compile(rxString)
            # return regex.match(hostname)
            h = hostname.replace(pattern.replace('*',''),'')
            if '.' in h:
                return False
            else:
                return True
        else:
            return hostname == pattern


    def verify(self, conn, cert, errnum, depth, ok):
        # Verify the certificate in the given context

        # print "depth: %d" % depth
        # print "Server name: %s" % conn.get_servername()
        # print "Certificate %s" % cert
        # print "subject: %s" % cert.get_subject().commonName

        # Verify hostname match
        hostname = conn.get_servername()
        pattern = cert.get_subject().commonName
        if depth == 0 and not self.hostname_match(hostname, pattern):
            sys.stderr.write("Certificate verification failed: Hostname did not match\n")
            return False

        # If we want to allow stale certificates check the expiration date on the certificate
        if self.allow_stale_certs is not None:
            expire_date = datetime.datetime.strptime(cert.get_notAfter(), "%Y%m%d%H%M%SZ")
            expired_ago = datetime.datetime.now() - expire_date
            if expired_ago.days > self.allow_stale_certs:
                sys.stderr.write("Certificate verification failed: Expired more then %d days ago.\n" % self.allow_stale_certs)
                return False

        elif cert.has_expired():
            # Allow stale certificated was not specify so simply check to see if it's expired or not
            sys.stderr.write("Certificate verification failed: Expired certificate.\n")
            return False

        # Dealing with a pinned certificate
        if self.pinnedcertificate is not None:

            try:
                f = open(self.pinnedcertificate, 'r')
                pinned_cert_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading pinned certificate file: %s\n" % self.pinnedcertificate)
                exit(1)

            # Check to make sure that the certificates match exactly by checking the SHA 256 hash
            pinned_cert = OpenSSL.crypto.load_certificate(pinned_cert_buff)
            pinned_cert_digest = pinned_cert.digest(b"sha256")
            server_cert_digest = cert.digest(b"sha256")

            if pinned_cert_digest != server_cert_digest:
                # SHA-256 hashes did not match
                sys.stderr.write("Certificate verification failed: Mismatched SHA 256.\n")
                return False

        # Check to see if it's on the CRL if we were provided a CRL file
        if self.revocations is not None:
            # Serial Numbers are encoded in capital hex in the PEM files so
            # we must format the certificate number as such to look it up
            # I haven't been able to test this yet
            serial_number = "%X" % cert.get_serial_number()
            if serial_number in self.revocations:
                sys.stderr.write("Certificate verification failed: Serial number in CRL.\n")
                return False

        return True

    def setup_connection(self, host, port):
        # This method is for creating a OpenSSL Connection instance with verification already performed
        # so that the connection is ready to make HTTP requests

        # Make a connection using the specified url
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        connection = OpenSSL.SSL.Connection(self.context, sock)

        # This specified the hostname to send as server name in client hello message for SNI implementation
        connection.set_tlsext_host_name(host)

        # Try to connect to the host
        try:
            connection.connect((host, port))
        except socket.gaierror:
            sys.stderr.write("scurl: (6) Could not resolve host: %s\n" % host)
            exit(1)
        except:
            sys.stderr.write("Coult not establish connection with: %s:d\n" % (host, port))
            exit(1)

        # Do the connection (secret) handshake
        # This is where verification of connection certificate will be called
        try:
            connection.do_handshake()
        except OpenSSL.SSL.WantReadError:
            sys.stderr.write("Encountered WantReadError in handshake.\n")
            exit(1)
        except OpenSSL.SSL.Error:
            # Certificate verification failed
            sys.stderr.flush()
            exit(1)

        return connection

    def curl_urls(self, urls):

        # Create the Context instance
        self.context = self.make_context()

        for url in urls:
            # Parse hostname and port from the url
            host, port = get_host_port(url)
            port = port if port is not None else self.default_port

            # Make connection and do handshake
            connection = self.setup_connection(host, port)

            # Make a HTTP request
            request = format_http_request(host)
            connection.send(request)

            # Now that the handshake and request have been completed
            # Receive chunks of data from the socket
            while True:
                try:
                    packet = connection.recv(self.buffer_size)
                except OpenSSL.SSL.ZeroReturnError:
                    # End of content
                    break
                except OpenSSL.SSL.WantReadError:
                    # Something happened
                    break
                except OpenSSL.SSL.Error:
                    sys.stderr.write("Connection died unexpectedly.\n")
                    break

                # Make sure not to print out the packet end mark
                if packet.endswith(self.packet_end):
                    sys.stdout.write(packet[:packet.index(self.packet_end)])
                else:
                    sys.stdout.write(packet)
                sys.stdout.flush()

                # Check for end of content
                if packet.endswith(self.packet_end) or len(packet) == 0:
                    break

            connection.shutdown()
            connection.close()

def get_SSL_method(args):
    # This function is for getting the SSL method
    # based on the command line arguments

    if args.tlsv1_0:
        return OpenSSL.SSL.TLSv1_METHOD
    elif args.tlsv1_1:
        return OpenSSL.SSL.TLSv1_1_METHOD
    elif args.tlsv1_2:
        return OpenSSL.SSL.TLSv1_2_METHOD
    elif args.sslv3:
        return OpenSSL.SSL.SSLv3_METHOD
    else:
        # Default to TLS 1.2
        return OpenSSL.SSL.TLSv1_2_METHOD

def get_host_port(url):
    # This function parses the host and port from a provided url
    # Return: a tuple of host, port where port is None if no port was provided
    parsed = urlparse.urlparse(url)
    host_port = parsed.netloc if parsed.netloc != '' else parsed.path

    if ":" in host_port:
        host, port = host_port.split(":")
        port = int(port)
    else:
        host, port = host_port, None

    return host, port

def format_http_request(url):
    # This is how to format an HTTP request
    request = "GET / HTTP/1.1\r\n" \
              "Host: %s\r\n" \
              "User-Agent: curl/7.52.1\r\n" \
              "Accept: */*\r\n\r\n" % url
    return request

def scurl(args):

    # Get the specified version of TLS to use
    method = get_SSL_method(args)

    # Instantiate a secure curler
    secure_curler = SecureCurl(method,
                               ciphers=args.ciphers,
                               crlfile=args.crlfile,
                               pinnedcertificate=args.pinnedcertificate,
                               cacert=args.cacert,
                               allow_stale_certs=args.allow_stale_certs)

    # curl all the URLS
    secure_curler.curl_urls(args.urls)

def main():
    # Command Line Argument parsing
    description = "scurl - secure transfer a URL"
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument("urls", nargs="+", help="List of URLs to make requests from")

    version_group = parser.add_argument_group("Versions")
    version_group.add_argument("--tlsv1.0", dest="tlsv1_0", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.0 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.1", dest="tlsv1_1", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.1 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.2,", dest="tlsv1_2", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.2 when connecting to a remote TLS server.")

    version_group.add_argument("-3", "--sslv3", dest="sslv3", action="store_true",
                               help="(SSL) Forces curl to use SSL version 3 when negotiating with a remote SSL server.")

    parser.add_argument("--ciphers", help="(TLS) Specify which ciphers to use in the connection with a colon-separated list.")

    parser.add_argument("--crlfile", help="(TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.")

    parser.add_argument("--cacert", help="(TLS) Tells curl to use ONLY the specified certificate file to verify the peer. The file may contain only one CA certificate. The certificate must be in PEM format. Normally curl is built to use a default file for this, so this option is typically used to alter that default file.")

    parser.add_argument("--allow-stale-certs", type=int, dest="allow_stale_certs", help="Accept a certificate C as valid if (a) C is an otherwise valid certificate that has expired and (b) C expired within the past N days.")

    parser.add_argument("--pinnedcertificate", help="Provide a public-key certificate file in PEM format. When a user passes this argument, the TLSl client will only send an application data to server if the server's TLS certificate is exactly the one contained in the specified file. This option will overrride everything else.")

    args = parser.parse_args()

    # Make sure that a non-negative integer was passed to this argument
    if args.allow_stale_certs is not None and args.allow_stale_certs < 0:
        parser.error("--allow-stale-certs must be non-negative integer.")

    # Pass off arguments to be curl'd
    scurl(args)

if __name__ == '__main__':
    main()