#!/usr/bin/env python
'''
CS 255, Winter 2017
Project 2: scurl

Group:
    Jon Deaton, jdeaton@stanford.edu
    Vincent-Pierre Berges, vpberges@stanford.edu
'''

import os
import sys
import OpenSSL
import socket
from urlparse import urlparse
import argparse

def get_from(url):

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    ctx = OpenSSL.SSL.Context(OpenSSL.SSL.SSLv23_METHOD)
    conn = OpenSSL.SSL.Connection(ctx, s)

    parsed_url = urlparse(url)
    proxy = (parsed_url.netloc, parsed_url.port)
    try:
        s.connect(proxy)
    except socket.error, e:
        print "Unable to connect to %s:%s %s" % (proxy[0], proxy[1], str(e))
        sys.exit(-1)

    s.send('GET / HTTP/1.1\nHost:%s\n\n' % url)
    packet = s.recv(256)
    s.shutdown()
    s.close()
    return packet

def try_socket():

    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # s.bind(('',80))  ?

    s.connect(("stackoverflow.com" , 80))
    # s.sendall("GET /\r\n")
    s.send('GET / HTTP/1.1\nHost: stackoverflow.com\n\n')
    print s.recv(256)
    s.close

def get_connection(url, context):
    # Get an OpenSSL connection
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    parsed_url = urlparse(url)

    sock.connect((url, 80))
    sock.send("CONNECT %s:80 HTTP/1.0\n\n" % url)

    #sock.send("CONNECT %s:%s HTTP/1.0\n\n" % (parsed_url.netloc, parsed_url.port))

    connection = OpenSSL.SSL.Connection(context, sock)
    return connection

def get_context(method, ciphers):
    # Initialize the context
    context = OpenSSL.SSL.Context(method)
    if ciphers is not None:
        context.set_cipher_list(ciphers)
    return context

def get_SSL_method(args):
    # This function is for getting the SSL method
    # based on the command line arguments

    if args.tlsv1_0:
        return OpenSSL.SSL.TLSv1_METHOD
    elif args.tlsv1_1:
        return OpenSSL.SSL.TLSv1_1_METHOD
    elif args.tlsv1_2:
        return OpenSSL.SSL.TLSv1_2_METHOD
    elif args.sslv3:
        return OpenSSL.SSL.SSLv3_METHOD
    else:
        # Default to TLS 1.2
        return OpenSSL.SSL.TLSv1_2_METHOD

def scurl(args):
    # Decide on which SSL protocol to use
    tls_method = get_SSL_method(args)

    # Get the context
    context = get_context(tls_method, args.ciphers)

    for url in args.urls:
        sock = get_connection(url, context)
        #sock.connect((url, 80))
        while 1:
            line = sys.stdin.readline()
            if line == '':
                break
            try:
                sock.send(line)
                sys.stdout.write(sock.recv(1024))
                sys.stdout.flush()
            except OpenSSL.SSL.Error:
                print 'Connection died unexpectedly'
                break

        sock.shutdown()
        sock.close()

def main():
    # Command Line Argument parsing
    description = "CS255: scurl - transfer a URL"
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument("urls", nargs="+", help="List of URLs to make requests from")

    version_group = parser.add_argument_group("Versions")
    version_group.add_argument("--tlsv1.0", dest="tlsv1_0", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.0 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.1", dest="tlsv1_1", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.1 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.2,", dest="tlsv1_2", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.2 when connecting to a remote TLS server.")

    version_group.add_argument("-3", "--sslv3", dest="sslv3", action="store_true",
                               help="(SSL) Forces curl to use SSL version 3 when negotiating with a remote SSL server.")

    parser.add_argument("--ciphers", nargs=1, help="(TLS) Specify which ciphers to use in the connection with a colon-separated list.")

    parser.add_argument("--crlfile", nargs=1, help="(TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.")

    parser.add_argument("--cacert", nargs=1, help="(TLS) Tells curl to use the specified certificate file to verify the peer.")

    parser.add_argument("--allow-stale-certs", type=int, nargs=1, help="Accept a certificate C as valid if (a) C is an otherwise valid certificate that has expired and (b) C expired within the past N days.")

    parser.add_argument("--pinnedcertificate", nargs=1, help="Provide a public-key file in PEM format.")

    args = parser.parse_args()

    # Pass off the arguments to be curl'd
    scurl(args)


if __name__ == '__main__':
    main()