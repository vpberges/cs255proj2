#!/usr/bin/env python
'''
CS 255, Winter 2017
Project 2: scurl - Secure curl

Group:
    Jon Deaton, jdeaton@stanford.edu
    Vincent-Pierre Berges, vpberges@stanford.edu
'''

import os
import sys
import OpenSSL
import socket
from urlparse import urlparse
import argparse
import datetime

class SecureCurl(object):
    # This class implements the functionality of curl but with TLS

    def __init__(self, method, ciphers=None, crlfile=None, pinnedcertificate=None,
                 cacert=None, allow_stale_certs=False):

        self.default_port = 443 # Default port for HTTPS requests
        self.packet_end = b'\r\n\r\n' # End of buffer
        self.timeout = 1 # socket.rev() timeout in seconds
        self.buffer_size = 1024 # Buffer size for packet recieving in bytes

        # Set instance vairables based on those from construction
        self.ciphers = ciphers
        self.method = method
        self.crlfile = crlfile
        self.cacert = cacert
        self.pinnedcertificate = pinnedcertificate
        self.allow_stale_certs = allow_stale_certs

        # The verificatoin mode used for Context.set_verify(mode, calback)
        # IDK what this is really i just got this from somewhere online
        # self.verify_mode = OpenSSL.SSL.VERIFY_PEER |\
        #                    OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT | \
        #                    OpenSSL.SSL.VERIFY_CLIENT_ONCE

        self.verify_mode = OpenSSL.SSL.VERIFY_NONE
        self.verify_mode = OpenSSL.SSL.VERIFY_PEER

        # This will contain a lookup table of hexidecmial encoded certificate cerial numbers
        self.revocations = None
        self.set_CRL()

    def make_context(self):
        # Initialize the context
        context = OpenSSL.SSL.Context(self.method)

        # Set the ciphers if necessary
        if self.ciphers is not None:
            context.set_cipher_list(self.ciphers)

        # Specify the CA Certificate to use for verification
        if self.cacert is not None:
            try:
                f = open(self.cacert, 'r')
                crt_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading CA certificate file: %s\n" % self.cacert)
                exit(1)

            # Use the certificate provided
            try:
                ca_crt = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, crt_buff)
            except:
                sys.stderr.write("Error loading CA certificate from: %s\n" % self.cacert)
                exit(1)

            context.use_certificate(ca_crt)

        # Set the verify callback
        context.set_verify(self.verify_mode, self.verify)

        return context

    def set_CRL(self):
        # Set the Certificate Revocation List if one was provided by the --crlfile argument
        if self.crlfile is not None:
            try:
                f = open(self.crlfile, 'r')
                crl_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading CRL file: %s\n" % self.crlfile)
                raise

            # Load the buffer into an OpenSSL CRL object
            crl = OpenSSL.crypto.load_crl(OpenSSL.crypto.FILETYPE_PEM, crl_buff)
            # Create a lookup table for revocations. These are formatted as capital hex strings
            self.revocations = set(map(lambda x: x.get_serial(), crl.get_revoked()))

    def verify(self, conn, cert, errnum, depth, ok):
        # Verify the certificate in the given context

        print 'Verifying certificate: %s' % cert.get_subject()
        print "Verifying ok? %s" % ok

        # Need to check the following:
        # 1) url is the same as the one that we requested
        # 2) the chain of certificates

        # If we want to allow stale certifiicates check the expiration date on the certificate
        if self.allow_stale_certs is not None:
            if 'notAfter' in cert:
                try:
                    expire_date = datetime.datetime.strptime(cert['notAfter'], "%b %d %H:%M:%S %Y %Z")
                except:
                    sys.stderr.write('Certificate date format unknow.\n')
                    exit(1)
                expired_ago = datetime.datetime.now() - expire_date
                if expired_ago.days <= self.allow_stale_certs:
                    return True
                else:
                    return False
            else:
                sys.stderr.write("Could not find certificate expiration date.\n")
                exit(1)

        elif cert.has_expired():
            # Allow stale certificated was not specify so simply check to see if it's expired or not
            return False

        # Dealing with the pinned certificate
        if self.pinnedcertificate is not None:

            try:
                f = open(self.pinnedcertificate, 'r')
                pinned_cert_buff = f.read()
                f.close()
            except:
                sys.stderr.write("Error reading pinned certificate file: %s\n" % self.pinnedcertificate)
                exit(1)

            server_cert_buff = OpenSSL.crypto.dump_certificate(cert)
            if pinned_cert_buff != server_cert_buff:
                return False

        # Check to see if it's on the CRL if we were provided a CRL file
        if self.revocations is not None:
            # Serial Numbers are encoded in capital hex in the PEM files so
            # we must format the certificate number as such to look it up
            # I haven't been able to test this yet
            serial_number = "%X" % cert.get_serial_number()
            if serial_number in self.revocations or True:
                return False

        return True

    def curl_urls(self, urls):

        # Get the context
        self.context = self.make_context()

        for url in urls:
            # Make a connection using the specified url
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            connection = OpenSSL.SSL.Connection(self.context, sock)

            # Try to connect to the host
            try:
                connection.connect((url, self.default_port))
            except socket.gaierror:
                sys.stderr.write("scurl: (6) Could not resolve host: %s\n" % url)
                exit(1)
            except:
                sys.stderr.write("Coult not establish connection with: %s\n" % url)
                exit(1)

            # Do the connection (secret) handshake
            # This is where verification of connection certificate will be called
            try:
                connection.do_handshake()
            except OpenSSL.SSL.WantReadError:
                sys.stderr.write("Encountered WantReadError in handshake.\n")
                exit(1)
            except OpenSSL.SSL.Error:
                sys.stderr.write("Certificate verification failed.\n")
                exit(1)

            # Make a HTTP request
            request = format_http_request(url)
            connection.send(request)

            # Now that the handshake and request have been completed
            #  Receive chunks of data from the socket
            while True:
                try:
                    packet = connection.recv(self.buffer_size)
                except OpenSSL.SSL.ZeroReturnError:
                    # End of content
                    break
                except OpenSSL.SSL.WantReadError:
                    # Something happened
                    break
                except OpenSSL.SSL.Error:
                    sys.stderr.write("Connection died unexpectedly.\n")
                    break

                # Make sure not to print out the packet end mark
                if packet.endswith(self.packet_end):
                    print "index: %d" % packet.index(self.packet_end)
                    sys.stdout.write(packet[:packet.index(self.packet_end)])
                else:
                    sys.stdout.write(packet)
                sys.stdout.flush()

                # Check for end of content
                if packet.endswith(self.packet_end) or len(packet) == 0:
                    break

            connection.shutdown()
            connection.close()

def get_SSL_method(args):
    # This function is for getting the SSL method
    # based on the command line arguments

    if args.tlsv1_0:
        return OpenSSL.SSL.TLSv1_METHOD
    elif args.tlsv1_1:
        return OpenSSL.SSL.TLSv1_1_METHOD
    elif args.tlsv1_2:
        return OpenSSL.SSL.TLSv1_2_METHOD
    elif args.sslv3:
        return OpenSSL.SSL.SSLv3_METHOD
    else:
        # Default to TLS 1.2
        return OpenSSL.SSL.TLSv1_2_METHOD

def format_http_request(url):
    # This is how to format an HTTP request
    request = "GET / HTTP/1.1\r\n" \
              "Host: %s\r\n" \
              "User-Agent: curl/7.52.1\r\n" \
              "Accept: */*\r\n\r\n" % url
    return request

def scurl(args):

    # Get the specified version of TLS to use
    method = get_SSL_method(args)

    # Instantiate a secure curler
    secure_curler = SecureCurl(method,
                               ciphers=args.ciphers,
                               crlfile=args.crlfile,
                               pinnedcertificate=args.pinnedcertificate,
                               cacert=args.cacert,
                               allow_stale_certs=args.allow_stale_certs)

    # curl all the URLS
    secure_curler.curl_urls(args.urls)

def main():
    # Command Line Argument parsing
    description = "scurl - secure transfer a URL"
    parser = argparse.ArgumentParser(description=description)

    parser.add_argument("urls", nargs="+", help="List of URLs to make requests from")

    version_group = parser.add_argument_group("Versions")
    version_group.add_argument("--tlsv1.0", dest="tlsv1_0", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.0 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.1", dest="tlsv1_1", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.1 when connecting to a remote TLS server.")

    version_group.add_argument("--tlsv1.2,", dest="tlsv1_2", action="store_true",
                               help="(TLS) Forces curl to use TLS version 1.2 when connecting to a remote TLS server.")

    version_group.add_argument("-3", "--sslv3", dest="sslv3", action="store_true",
                               help="(SSL) Forces curl to use SSL version 3 when negotiating with a remote SSL server.")

    parser.add_argument("--ciphers", help="(TLS) Specify which ciphers to use in the connection with a colon-separated list.")

    parser.add_argument("--crlfile", help="(TLS) Provide a file using PEM format with a Certificate Revocation List that may specify peer certificates that are to be considered revoked.")

    parser.add_argument("--cacert", help="(TLS) Tells curl to use ONLY the specified certificate file to verify the peer. The file may contain only one CA certificate. The certificate must be in PEM format. Normally curl is built to use a default file for this, so this option is typically used to alter that default file.")

    parser.add_argument("--allow-stale-certs", type=int, dest="allow_stale_certs", help="Accept a certificate C as valid if (a) C is an otherwise valid certificate that has expired and (b) C expired within the past N days.")

    parser.add_argument("--pinnedcertificate", help="Provide a public-key certificate file in PEM format. When a user passes this argument, the TLSl client will only send an application data to server if the server's TLS certificate is exactly the one contained in the specified file. This option will overrride everything else.")

    args = parser.parse_args()

    # Pass off arguments to be curl'd
    scurl(args)

if __name__ == '__main__':
    main()